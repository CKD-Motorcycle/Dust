package $packagename

import (
  "time"
  "git.torproject.org/pluggable-transports/obfs4.git/common/csrand"
  "github.com/blanu/Dust/go/Dust"
  "github.com/blanu/Dust/go/DustModel/dist"
  "github.com/blanu/Dust/go/DustModel/huffman"
)

type $model_type struct {
  $weights.decl
  $huffman.decl
}

type $codec_type struct {
  *$model_type
  $duration.decl
  $packet_sleep.decl
  $packet_length.decl
  $encode.decl
  $decode.decl
}

func computeModel() (result *$model_type) {
  var err error
  result = &$model_type{
    $weights.data}
  $huffman.body
  return
}

func (model $model_type) newCodec() (result *$codec_type, err error) {
  // TODO: is this the best choice of source to use?
  prng := csrand.Rand
  result = &$codec_type{
    $duration.data
    $packet_sleep.data
    $packet_length.data
    $encode.data
    $decode.data}
  return
}

func (model $model_type) MakeClientPair() (Dust.ShapingEncoder, Dust.ShapingDecoder, error) {
  codec, err := model.newCodec()
  return codec, codec, err
}

func (model $model_type) MakeServerPair() (Dust.ShapingEncoder, Dust.ShapingDecoder, error) {
  codec, err := model.newCodec()
  return codec, codec, err
}

func init() {
  model := computeModel()
  constructor := func(params map[string]string) (Dust.ShapingModel, error) {
    if err := Dust.CheckUnackedParams(params, nil); err != nil {
      return nil, err
    }

    return model, nil
  }

  Dust.RegisterModel("$name", constructor)
}

func (self $codec_type) wholeStreamDurationMillis() uint16 {
  $duration.body
}

func (self $codec_type) WholeStreamDuration() time.Duration {
  return time.Duration(self.wholeStreamDurationMillis()) * time.Millisecond
}

func (self $codec_type) MaxPacketLength() uint16 {
  return 65535
}

func (self $codec_type) NextPacketLength() uint16 {
  $packet_length.body
}

func (self $codec_type) nextPacketSleepMillis() uint16 {
  $packet_sleep.body
}

func (self $codec_type) NextPacketSleep() time.Duration {
  return time.Duration(self.nextPacketSleepMillis()) * time.Millisecond
}

func allocatingRecode(f func(dst []byte, src []byte) (dn int, sn int), in []byte) []byte {
  out := make([]byte, len(in))
  outTail := out

  for len(in) > 0 {
    if len(outTail) == 0 {
      newOut := make([]byte, 1 + len(out)*2)
      _ = copy(newOut, out)
      outTail = newOut[len(out):]
      out = newOut
    }

    dn, sn := f(outTail, in)
    if sn == 0 {
      // TODO: make sure this invariant should actually hold
      panic("no recode progress?!")
    }
    outTail = outTail[dn:]
    in = in[sn:]
  }

  return out[:len(out)-len(outTail)]
}

func (codec $codec_type) ShapeBytes(in []byte) []byte {
  return allocatingRecode(codec.decoder.Decode, in)
}

func (codec $codec_type) UnshapeBytes(in []byte) []byte {
  return allocatingRecode(codec.encoder.Encode, in)
}

#+TITLE: Notes on Dust Go implementation
Updated: [2015-01-26 Mon]

* State
** Packaging
Copyright/licensing information:

  - Most of the code currently in go/ is by (and copyrighted by) Drake Wilson and is expected to
    wind up MIT-licensed as this section resolves.

  - DustModel/dist was moved from a fork of another Go package by blanu earlier, and it refers to
    its own LICENSE file which may not have been copied; it claims to be BSD-style.

Need better external documentation in general as things become more stable.

** Crypto primitives
Skein-512-256 is being used instead of Skein-256-256, and the MAC/stream stuff is a little ambiguous right
now versus the original Dust specification used.  We're using dchest's Skein, which needs to be audited.

The SecretBytes API is a little wonky given Go's memory and execution model, and is mostly voodoo.  Possibly
it should be taken out entirely.

** Crypto/framing layer
Most of this should probably work now, but the usage of primitives has been moved around and needs to be
locked down and documented.

** Shaping layer
The API for models has been improved; blanu's model generator hasn't been

There's also a silly pseudo-model available.  Loopback communication has been verified working with this
model, modulo some protocol-design difficulties (via the Dust spec) regarding handshake latency versus shaping
padding.

Connection durations are not handled.  The ensemble protocol isn't handled, as it's not clear how to deal with
that practically yet (and it doesn't seem to have been in the original Haskell codebase anyway?).

** Test proxy
This mostly seems to work, protocol-wise.  The goroutine composition needs to be reworked.

Doing statistical tests would be useful here.

** Key tool
This mostly works but should have a cleaner CLI.

* Tasks
** Integrate model generator properly
** Handle connection durations
** Determine what to do about the ensemble protocol
Was this ever verified functional elsewhere?  Can this be deferred?
** Code cleanup
*** Rename newPlainDataFrame -> newDataFrame
*** Recheck goroutine composition
*** Recheck concrete versus interface type exports
*** Decide what to do with SecretBytes: propagate destroy signals or remove entirely
Finalizers are useful as a stopgap if they're kept.  The Skein stuff probably needs
to be copied in-tree and then modified to allow zeroing the structure... ?

It should probably be possible to use move semantics for SecretBytes, which would make
the ownership transitions safer.

Then again, the mainline Go crypto packages don't have any early-destroy semantics
here at all, and it's not entirely clear that the attack set aided by this is usefully
delimitable.
*** Reformatting
Some things probably aren't aligned properly by gofmt standards.
*** Get needed entropy earlier in CryptoSession initialization to avoid later failures
** Documentation
*** Overview of packages
*** Top-level type/function pass
*** crypting: Buffer ownership
*** As-built protocol documentation
** Interfacing
*** Lock down CLI for test proxy
*** Lock down CLI for key tool
*** Lock down file format for private identity files
**** Consider allowing a PBKDF for this
** Protocol modifications
*** Avoid bogus key material reuse
*** Avoid stuck states during handshaking
*** Figure out MTU situation
** Deferred
*** Higher-performance buffer discipline for models?

* (metadata)

Local variables:
mode: org
mode: auto-fill
fill-column: 110
End:

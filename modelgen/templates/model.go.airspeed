package $packagename

import (
  "time"
  "git.torproject.org/pluggable-transports/obfs4.git/common/csrand"
  "github.com/blanu/Dust/go/Dust"
  "github.com/blanu/Dust/go/DustModel/dist"
  "github.com/blanu/Dust/go/DustModel/huffman"
)

type $model_type struct {
  $huffman.decl
}

type $codec_type struct {
  *$model_type
  $packet_sleep.decl
  $packet_length.decl
  $encode.decl
  $decode.decl
  $sequence.decl
}

func computeModel() (result *$model_type) {
  var err error
  result = &$model_type{}
  $huffman.incoming
  $huffman.outgoing
  return
}

func newCodec(direction bool) (result *$codec_type, err error) {
  // TODO: is this the best choice of source to use?
  prng := csrand.Rand

  model := computeModel()

  if direction {
    result = &$codec_type{
      $packet_sleep.incoming
      $packet_length.incoming
      $encode.incoming
      $decode.outgoing,
      $sequence.incoming}
  } else {
    result = &$codec_type{
      $packet_sleep.outgoing
      $packet_length.outgoing
      $encode.outgoing
      $decode.incoming,
      $sequence.outgoing}
  }
  return
}

func (self $model_type) MakeClientPair() (Dust.ShapingEncoder, Dust.ShapingDecoder, error) {
  incomingCodec, err1 := newCodec(true)
  if err1 != nil {
    return nil, nil, err1
  } else {
    outgoingCodec, err2 := newCodec(false)
    if err2 != nil {
      return nil, nil, err2
    } else {
      return incomingCodec, outgoingCodec, nil
    }
  }
}

func (self $model_type) MakeServerPair() (Dust.ShapingEncoder, Dust.ShapingDecoder, error) {
  incomingCodec, err1 := newCodec(true)
  if err1 != nil {
    return nil, nil, err1
  } else {
    outgoingCodec, err2 := newCodec(false)
    if err2 != nil {
      return nil, nil, err2
    } else {
      return outgoingCodec, incomingCodec, nil
    }
  }
}

func init() {
  model := computeModel()
  constructor := func(params map[string]string) (Dust.ShapingModel, error) {
    if err := Dust.CheckUnackedParams(params, nil); err != nil {
      return nil, err
    }

    return model, nil
  }

  Dust.RegisterModel("$name", constructor)
}

func clampUint16(n float64) uint16 {
  // Use positive test for in-range to handle NaN properly, just in case.
  switch {
  case 0.0 <= n && n <= 65535.0:
    return uint16(n)
  case 65535.0 < n:
    return 65535
  default:
    return 0
  }
}

func (self $codec_type) WholeStreamDuration() time.Duration {
//  return time.Duration($duration.exp) * time.Millisecond
  return time.Duration(0) * time.Millisecond
}

func (self $codec_type) MaxPacketLength() uint16 {
  return 65535
}

func (self $codec_type) NextPacketLength() uint16 {
  return $packet_length.expr
}

func (self $codec_type) NextPacketSleep() time.Duration {
  return time.Duration($packet_sleep.expr) * time.Millisecond
}

func (codec $codec_type) ShapeBytes(dst []byte, src []byte) (dn int, sn int) {
  var buffer []byte
  var consumed int

  if codec.encoder_position == 0 {
    $decode.body
    buffer=append(codec.sequence , buffer)
    codec.
  } else {
    $decode.body
  }

  return buffer, consumed
}

func (codec $codec_type) UnshapeBytes(dst, src []byte) (dn, sn int) {
  if codec.decoder_position < codec. {

  } else {
    $encode.body
  }
}
